package services

import (
	"bytes"
	"dhl/models"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
)

type GeminiService interface {
	GenerateAssessment(req models.GenerateAssessmentRequest) (*models.SheetAssessment, error)
}

type GeminiServiceImpl struct{}

func NewGeminiService() GeminiService {
	return &GeminiServiceImpl{}
}

type GeminiRequest struct {
	Contents []GeminiContent `json:"contents"`
}

type GeminiContent struct {
	Parts []GeminiPart `json:"parts"`
}

type GeminiPart struct {
	Text string `json:"text"`
}

type GeminiResponse struct {
	Candidates []GeminiCandidate `json:"candidates"`
}

type GeminiCandidate struct {
	Content GeminiContent `json:"content"`
}

func (s *GeminiServiceImpl) GenerateAssessment(req models.GenerateAssessmentRequest) (*models.SheetAssessment, error) {
	apiKey := os.Getenv("GEMINI_API_KEY")
	if apiKey == "" {
		return nil, errors.New("GEMINI_API_KEY not configured")
	}

	// Build the prompt based on request parameters
	difficultyMap := map[int]string{
		1: "very easy (beginner level)",
		2: "easy (basic level)",
		3: "moderate (intermediate level)",
		4: "hard (advanced level)",
		5: "very hard (expert level)",
	}

	difficultyDesc := difficultyMap[req.DifficultyLevel]
	questionType := "multiple choice questions (MCQ)"
	if req.QuestionType != "" {
		questionType = req.QuestionType
	}

	assessmentName := req.AssessmentName
	if assessmentName == "" {
		assessmentName = fmt.Sprintf("%s Assessment - Level %d", req.Topic, req.DifficultyLevel)
	}

	prompt := fmt.Sprintf(`Generate %d %s about "%s" at %s difficulty level.

IMPORTANT: You must respond with ONLY a valid JSON object, no additional text, explanation, or markdown formatting.

The JSON structure must be:
{
  "assessment_name": "%s",
  "questions": [
    {
      "title": "question text here",
      "mandatory_to_answer": true,
      "question_type": "multiple_choice",
      "tags": ["tag1", "tag2"],
      "options": [
        {"label": "option A", "is_correct": false, "score": 0},
        {"label": "option B", "is_correct": true, "score": 1},
        {"label": "option C", "is_correct": false, "score": 0},
        {"label": "option D", "is_correct": false, "score": 0}
      ]
    }
  ]
}

Requirements:
1. Each question must have exactly 4 options
2. Only ONE option should have "is_correct": true
3. Correct answer should have "score": 1, others "score": 0
4. Questions should be relevant to "%s" topic
5. Difficulty should be %s
6. Add relevant tags to each question (e.g., specific concepts, subtopics)
7. Make questions clear and unambiguous
8. Ensure all questions are unique and diverse

Generate the JSON now:`,
		req.NumberOfQuestions,
		questionType,
		req.Topic,
		difficultyDesc,
		assessmentName,
		req.Topic,
		difficultyDesc)

	// Call Gemini API
	geminiReq := GeminiRequest{
		Contents: []GeminiContent{
			{
				Parts: []GeminiPart{
					{Text: prompt},
				},
			},
		},
	}

	reqBody, err := json.Marshal(geminiReq)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	url := fmt.Sprintf("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=%s", apiKey)

	resp, err := http.Post(url, "application/json", bytes.NewBuffer(reqBody))
	if err != nil {
		return nil, fmt.Errorf("failed to call Gemini API: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		log.Printf("Gemini API error: %s", string(body))
		return nil, fmt.Errorf("gemini API returned status %d: %s", resp.StatusCode, string(body))
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	var geminiResp GeminiResponse
	if err := json.Unmarshal(body, &geminiResp); err != nil {
		return nil, fmt.Errorf("failed to unmarshal Gemini response: %w", err)
	}

	if len(geminiResp.Candidates) == 0 || len(geminiResp.Candidates[0].Content.Parts) == 0 {
		return nil, errors.New("no content generated by Gemini")
	}

	generatedText := geminiResp.Candidates[0].Content.Parts[0].Text

	// Clean up the response - remove markdown code blocks if present
	generatedText = strings.TrimSpace(generatedText)
	generatedText = strings.TrimPrefix(generatedText, "```json")
	generatedText = strings.TrimPrefix(generatedText, "```")
	generatedText = strings.TrimSuffix(generatedText, "```")
	generatedText = strings.TrimSpace(generatedText)

	log.Printf("Generated text from Gemini: %s", generatedText)

	// Parse the generated JSON into a temporary structure with string tags
	type TempQuestion struct {
		Title             string               `json:"title"`
		MandatoryToAnswer bool                 `json:"mandatory_to_answer"`
		QuestionType      string               `json:"question_type"`
		Options           []models.SheetOption `json:"options"`
		Tags              []string             `json:"tags,omitempty"`
	}
	type TempAssessment struct {
		AssessmentName string         `json:"assessment_name"`
		Questions      []TempQuestion `json:"questions"`
		Tags           []string       `json:"tags,omitempty"`
	}

	var tempAssessment TempAssessment
	if err := json.Unmarshal([]byte(generatedText), &tempAssessment); err != nil {
		log.Printf("Failed to parse generated JSON: %v", err)
		log.Printf("Generated text: %s", generatedText)
		return nil, fmt.Errorf("failed to parse generated assessment: %w", err)
	}

	// Convert to actual assessment structure with TagRequest
	assessment := models.SheetAssessment{
		AssessmentName: tempAssessment.AssessmentName,
		Questions:      make([]models.SheetQuestion, len(tempAssessment.Questions)),
		Tags:           convertStringTagsToTagRequests(tempAssessment.Tags),
	}

	// Convert questions with their tags
	for i, tq := range tempAssessment.Questions {
		assessment.Questions[i] = models.SheetQuestion{
			Title:             tq.Title,
			MandatoryToAnswer: tq.MandatoryToAnswer,
			QuestionType:      tq.QuestionType,
			Options:           tq.Options,
			Tags:              convertStringTagsToTagRequests(tq.Tags),
		}
	}

	// Add user-provided tags to assessment if specified
	if len(req.Tags) > 0 {
		assessment.Tags = append(assessment.Tags, req.Tags...)
	}

	// Validate the assessment
	if len(assessment.Questions) == 0 {
		return nil, errors.New("no questions were generated")
	}

	for i, q := range assessment.Questions {
		if len(q.Options) < 2 {
			return nil, fmt.Errorf("question %d has less than 2 options", i+1)
		}
		hasCorrectAnswer := false
		for _, opt := range q.Options {
			if opt.IsCorrect {
				hasCorrectAnswer = true
				break
			}
		}
		if !hasCorrectAnswer {
			return nil, fmt.Errorf("question %d has no correct answer", i+1)
		}
	}

	return &assessment, nil
}

// convertStringTagsToTagRequests converts a simple string array of tags to TagRequest format
// Each tag becomes a separate TagRequest with only child_tags (no parent)
func convertStringTagsToTagRequests(tags []string) []models.TagRequest {
	if len(tags) == 0 {
		return nil
	}

	var tagRequests []models.TagRequest
	for _, tag := range tags {
		tagRequests = append(tagRequests, models.TagRequest{
			ChildTags: []string{tag},
		})
	}

	return tagRequests
}
